/**
 * Пример для Arduino Nano.
 * 
 * Плавно меняем яркость светодиода.
 * 
 * ШИМ (Широтно-импульсная модуляция)
 * PWM (Pulse-width modulation)
 * 
 * Fast PWM (Быстрый режим ШИМ):
 * 
 * В режиме Fast PWM таймер работает как обычный счётчик, который постоянно считает от 0 до определённого максимального значения (TOP). 
 * В случае 8-битного таймера (например, Timer0), это значение равно 255.
 * 
 * 1) Начало цикла: 
 * Каждый раз, когда счётчик таймера достигает 0, ШИМ-выход (например, порт PD6) становится высоким (HIGH).
 * 
 * 2) Середина цикла: 
 * Таймер продолжает считать. Когда счётчик достигает значения, 
 * которое вы задали в регистре сравнения OCRnx, ШИМ-выход становится низким (LOW).
 * 
 * 3) Конец цикла: 
 * Счётчик продолжает считать до 255 и затем сбрасывается к 0, начиная новый цикл.
 *
 * Чем большее значение вы запишете в регистр OCRnx, тем дольше ШИМ-выход будет оставаться высоким в течение одного цикла, 
 * что и приводит к увеличению средней мощности сигнала.
 * 
 * Формула расчета времени:
 *  T(Предделитель) = (Предделитель x (TOP + 1)) / Частоту МК
 * 
 * T (1) = (1 x (255 + 1)) / 16 000 000 = 16 us (микросекунд)
 * T (8) = (8 x (255 + 1)) / 16 000 000 = 128 us (микросекунд)
 * T (64) = (64 x (255 + 1)) / 16 000 000 = 1024 us (микросекунд) = 1 ms (миллисекунда)
 * T (256) = (256 x (255 + 1)) / 16 000 000 = 4096 us (микросекунд) = 4 ms (миллисекунд)
 * T (1024) = (1024 x (255 + 1)) / 16 000 000 = 16384 us (микросекунд) = 16 ms (миллисекунд)
 * 
 * Формула расчета частоты:
 *  F(Предделитель) = Частоту МК / (Предделитель x (TOP + 1))
 * 
 * T (1) = 16 000 000 / (1 x (255 + 1)) = 62500 Hz = 62,5 KHz
 * T (8) = 16 000 000 / (8 x (255 + 1)) = 7812,5 Hz = 7,81 KHz
 * T (64) = 16 000 000 / (64 x (255 + 1)) = 976,56 Hz
 * T (256) = 16 000 000 / (256 x (255 + 1)) = 244,14 Hz
 * T (1024) = 16 000 000 / (1024 x (255 + 1)) = 61,03 Hz
 * 
 * Порты вывода:
 * 
 * Таймер 0 (8-битный)
 * - OC0A (Output Compare A) соответствует выводу PD6.
 * - OC0B (Output Compare B) соответствует выводу PD5.
 * 
 * Таймер 1 (16-битный)
 * - OC1A (Output Compare A) соответствует выводу PB1
 * - OC1B (Output Compare B) соответствует выводу PB2
 * 
 * Таймер 2 (8-битный)
 * - OC2A (Output Compare A) соответствует выводу PB3
 * - OC2B (Output Compare B) соответствует выводу PD3
 */

#include <avr/io.h>
#include <util/delay.h>
#include <avr/pgmspace.h>

// Таблица значений для более натурального свечения светодиода.
const uint8_t brightness_table[256] PROGMEM = {
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
    1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,
    2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 3, 3,
    3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4,
    4, 4, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 7,
    7, 7, 7, 7, 8, 8, 8, 8, 8, 9, 9, 9, 9, 10, 10, 10,
    10, 11, 11, 11, 12, 12, 12, 13, 13, 13, 14, 14, 15, 15, 15, 16,
    16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 23, 23, 24, 25,
    25, 26, 27, 28, 28, 29, 30, 31, 32, 33, 34, 34, 35, 36, 37, 38,
    39, 40, 41, 42, 43, 44, 46, 47, 48, 49, 50, 52, 53, 54, 56, 57,
    58, 60, 61, 63, 64, 66, 67, 69, 70, 72, 73, 75, 77, 78, 80, 82,
    84, 85, 87, 89, 91, 93, 95, 97, 99, 101, 103, 105, 107, 109, 111, 114,
    116, 118, 121, 123, 125, 128, 130, 133, 135, 138, 140, 143, 146, 149, 151, 154,
    157, 160, 163, 166, 169, 172, 175, 178, 181, 184, 188, 191, 194, 198, 201, 204,
    208, 211, 215, 218, 222, 226, 229, 233, 237, 241, 245, 249, 253, 255, 255, 255
};

#define LED_PIN PD6 // PD6/OC0A (D6)

// Чем меньше значение в OCR0A, тем выше скважность (светодиод горит тусклее).
// Чем больше значение в OCR0A, тем ниже скважность (светодиод горит ярче).
void set_led_value(uint8_t value) {
  OCR0A = value;
}

int main(void) {
  DDRD |= (1<<LED_PIN); // Настройка LED на выход

  // Настройка делителя (TCCR0B - Timer/Counter Control Register B)

  // TCCR0B |= (1<<CS00); // Задаем prescaler = 1 (16 us / 62,5 KHz) (CS02=0, CS01=0, CS00=1)
  // TCCR0B |= (1<<CS01); // Задаем prescaler = 8 (128 us / 7,81 KHz) (CS02=0, CS01=1, CS00=0)
  TCCR0B |= (1<<CS01) | (1<<CS00); // Задаем prescaler = 64 (1 ms / 976,56 Hz) (CS02=0, CS01=1, CS00=1)
  // TCCR0B |= (1<<CS02); // Задаем prescaler = 256 (4 ms / 244,14 Hz) (CS02=1, CS01=0, CS00=0)
  // TCCR0B |= (1<<CS02) | (1<<CS00); // Задаем prescaler = 1024 (16 ms / 61,03 Hz) (CS02=1, CS01=0, CS00=1)

  TCCR0A |= (1<<COM0A1); // Не инверсный режим (COM0A1=1, COM0A0=0)
  // TCCR0A |= (1<<COM0A1) | (1<<COM0A0); // Инверсный режим (COM0A1=1, COM0A0=1)

  // Задаем режим работы Fast PWM (WGM02=0, WGM01=1, WGM00=1)
  TCCR0A |= (1<<WGM01) | (1<<WGM00);

  // TCNT0 // Хранит текущее значение счетчика (доступен для чтения и записи)

  uint8_t direction = 1;
  uint8_t counter = 0;

  while (1) {

    if (direction) {
      if (counter < 255) {
        counter++;
      } else {
        direction = 0;
      }
    } else {
      if (counter > 0) {
        counter--;
      } else {
        direction = 1;
      }
    }

    set_led_value(pgm_read_byte(&brightness_table[counter]));

    _delay_ms(10);
  }
}